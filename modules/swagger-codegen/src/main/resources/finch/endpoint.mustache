package {{packageName}}

import com.twitter.finagle.Service
import com.twitter.finagle.http.{Request, Response, Status}
import com.twitter.finagle.http.exp.Multipart.FileUpload
import com.twitter.io.Buf
import com.twitter.util.Future
import io.finch._, items._
import io.circe.{Encoder, Json}
import io.circe.syntax._
import io.finch.circe._
import io.circe.generic.semiauto._
import java.nio.charset.Charset
import scala.concurrent.ExecutionContext

import {{apiPackage}}._

/**
 * Provides the paths and endpoints for all the API's public service methods.
 */
object endpoint {


  private val printer = io.circe.Printer.noSpaces.copy(dropNullKeys = true)

  def encodeException[E](errorHandler: PartialFunction[Exception, GenericResponse[E]])(implicit encoder: Encoder[E]): Encode.Json[Exception] = {
    Encode.json[Exception] {
      case (e:Exception, charset:Charset) if errorHandler.isDefinedAt(e) =>
        Buf.ByteArray.Owned(printer.pretty(errorHandler(e).entity.asJson).getBytes(charset))
      case (e:Exception, charset:Charset) =>
        Buf.ByteArray.Owned(printer.pretty(Json.obj("message" -> Json.fromString(e.getMessage))).getBytes(charset))
      }
  }

  /**
  * Compiles together all the endpoints relating to public service methods.
  *
  * @return A service that contains all provided endpoints of the API.
  */
  def makeService[E](da: DataAccessor, errorHandler: PartialFunction[Exception, GenericResponse[E]])(implicit ec:ExecutionContext, errorEntityEncoder:Encoder[E]): Service[Request, Response] = {
    implicit val exceptionEncoder = encodeException(errorHandler)
    (
      {{#apiInfo}}
          {{#apis}}
              {{classname}}(ec).endpoints(da) {{^-last}} :+:{{/-last}}
          {{/apis}}
      {{/apiInfo}}
    ).handle({
      case e: Exception if errorHandler.isDefinedAt(e) =>
        val resp = errorHandler(e)
        resp.headers.foldLeft(Output.failure(e, Status.fromCode(resp.status)))((out, h) => out.withHeader(h.name -> h.value))
    }).toService
  }
}